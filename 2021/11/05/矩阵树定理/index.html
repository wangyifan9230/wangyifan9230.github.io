<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>
<meta name="description" content="矩阵树定理是利用矩阵行列式计算图的生成树个数的一个定理.">
<meta property="og:type" content="article">
<meta property="og:title" content="矩阵树定理">
<meta property="og:url" content="http://example.com/2021/11/05/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/index.html">
<meta property="og:site_name" content="demonlover的博客">
<meta property="og:description" content="矩阵树定理是利用矩阵行列式计算图的生成树个数的一个定理.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://z3.ax1x.com/2021/07/12/WPFTZd.png">
<meta property="article:published_time" content="2021-11-04T17:23:25.000Z">
<meta property="article:modified_time" content="2022-01-15T17:10:02.187Z">
<meta property="article:author" content="demonlover">
<meta property="article:tag" content="线性代数">
<meta property="article:tag" content="矩阵树定理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://z3.ax1x.com/2021/07/12/WPFTZd.png">


<link rel="canonical" href="http://example.com/2021/11/05/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2021/11/05/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/","path":"2021/11/05/矩阵树定理/","title":"矩阵树定理"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>矩阵树定理 | demonlover的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">demonlover的博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">lovexin</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">1.</span> <span class="nav-text">定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%A0%E6%9D%A1%E5%BC%95%E7%90%86"><span class="nav-number">1.1.</span> <span class="nav-text">几条引理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86"><span class="nav-number">1.2.</span> <span class="nav-text">矩阵树定理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86%E7%9A%84%E5%90%84%E7%A7%8D%E5%BD%A2%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">矩阵树定理的各种形式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E8%AE%B0%E5%8F%B7%E8%AF%B4%E6%98%8E"><span class="nav-number">2.1.</span> <span class="nav-text">无向图记号说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E8%AE%B0%E5%8F%B7%E8%AF%B4%E6%98%8E"><span class="nav-number">2.2.</span> <span class="nav-text">有向图记号说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86%E7%9A%84%E5%90%84%E7%A7%8D%E5%BD%A2%E5%BC%8F-1"><span class="nav-number">2.3.</span> <span class="nav-text">矩阵树定理的各种形式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BEST%E5%AE%9A%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">BEST定理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">例题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#solution"><span class="nav-number">4.0.1.</span> <span class="nav-text">solution</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#solution-1"><span class="nav-number">4.0.2.</span> <span class="nav-text">solution</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#solution-2"><span class="nav-number">4.0.3.</span> <span class="nav-text">solution</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%80%83%E8%99%91%E5%8A%A0%E4%B8%8A%E8%BE%B9%E6%9D%83%E4%BC%9A%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="nav-number">4.1.</span> <span class="nav-text">考虑加上边权会是什么样的</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#solution-3"><span class="nav-number">4.1.1.</span> <span class="nav-text">solution</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98"><span class="nav-number">4.2.</span> <span class="nav-text">经典问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%90%91%E6%89%A9%E5%B1%95"><span class="nav-number">4.3.</span> <span class="nav-text">有向扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#solution-4"><span class="nav-number">4.3.1.</span> <span class="nav-text">solution</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#solution-5"><span class="nav-number">4.3.2.</span> <span class="nav-text">solution</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BEST%E5%AE%9A%E7%90%86%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E7%9F%A9%E9%98%B5"><span class="nav-number">5.</span> <span class="nav-text">BEST定理一个新的矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#solution-6"><span class="nav-number">5.0.1.</span> <span class="nav-text">solution</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%90%91%E6%A0%91%E5%94%AF%E4%B8%80%E5%AF%B9%E5%BA%94%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF"><span class="nav-number">5.0.2.</span> <span class="nav-text">内向树唯一对应欧拉回路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E5%AF%B9%E5%BA%94%E5%94%AF%E4%B8%80%E5%86%85%E5%90%91%E6%A0%91"><span class="nav-number">5.0.3.</span> <span class="nav-text">欧拉回路对应唯一内向树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%85"><span class="nav-number">5.1.</span> <span class="nav-text">补充</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">demonlover</p>
  <div class="site-description" itemprop="description">foreverlasting</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/05/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="demonlover">
      <meta itemprop="description" content="foreverlasting">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="demonlover的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          矩阵树定理
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-05 01:23:25" itemprop="dateCreated datePublished" datetime="2021-11-05T01:23:25+08:00">2021-11-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-01-16 01:10:02" itemprop="dateModified" datetime="2022-01-16T01:10:02+08:00">2022-01-16</time>
      </span>

  
</div>


          
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>矩阵树定理是利用矩阵行列式计算图的生成树个数的一个定理.</p>
<span id="more"></span>
<hr>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h2><p>首先讨论无向图 $G = \left( V,E \right)$ (允许重边, 不允许自环). 定义其度数矩阵 $D(G)$ 为</p>
<script type="math/tex; mode=display">
D_{i,i}(G)=\deg(v_i),\quad D_{i,j}(G)=0\;\;(i\neq j)</script><p>定义其邻接矩阵 $A(G)$ 为</p>
<script type="math/tex; mode=display">
A_{i,j}(G)=\# \{e\in E(G)\;|\;e=(v_i,v_j)\}</script><p>将 $G$ 的每条边任意指定一个方向, 定义 $G$ 的关联矩阵 (Incidence matrix) $M(G)$ ($M$ 是 $|V|\times|E|$ 的矩阵)为:</p>
<script type="math/tex; mode=display">
M_{i,j}= 
\begin{cases}
-1,\quad \ \ & v_i \text{是} e_j \text{的起点} \\
1,\quad \ \ & v_i \text{是} e_j \text{的终点} \\
0,\quad \ \ & otherwise
\end{cases}</script><p>定义 $G$ 的拉普拉斯矩阵 (Laplace matrix) $L(G)$ 为 </p>
<script type="math/tex; mode=display">
L(G)=D(G)-A(G)</script><p>也可以形象的表示为</p>
<script type="math/tex; mode=display">
L_{i,j} = 
\begin{cases}
-m_{i,j},\quad \ \ & i \not= j,v_i \text{和},v_j \text{之间有} m_{i,j} \text{条边} \\
\operatorname{deg}(v_i),\quad \ \ & i = j
\end{cases}</script><p><strong>举例</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/WPFTZd"><img src="https://z3.ax1x.com/2021/07/12/WPFTZd.png" alt="WPFTZd.png"></a></p>
<p>上图的关联矩阵 $M$ 和拉普拉斯矩阵 $L$ 分别是:</p>
<script type="math/tex; mode=display">
M = 
\left[\begin{array}{cccc}
1& 0& 0& -1& -1\\
-1& -1& -1& 0& 0\\
0& 0& 1& 1& 0\\
0& 1& 0& 0& 1
\end{array}\right], 
L = \left[\begin{array}{cccc}
3& -1& -1& -1\\
-1& 3& -1& -1\\
-1& -1& 2& 0\\
-1& -1& 0& 2
\end{array}\right]</script><p>容易发现 $L$ 是对称的.实际上非主对角线上的元素也可以不是 $-1$ ,因为图 $G$ 允许重边存在.</p>
<hr>
<h3 id="几条引理"><a href="#几条引理" class="headerlink" title="几条引理"></a><strong>几条引理</strong></h3><blockquote>
<p>Lemma1: $MM^T = L$ ,其中 $M^T$ 表示 $M$ 的转置.</p>
</blockquote>
<p>证明:</p>
<script type="math/tex; mode=display">
(MM^T)_{i,j} = \sum_{e_k \in E}{M_{i,k}M^T_{k,j}} = \sum_{e_k \in E}{M_{i,k}M_{j,k}}</script><p>然后分情况讨论.<br>当 $i \not= j$时,当且仅当存在一条边 $e_k \in E$ 把 $v_i,v_j$ 连起来时, $M_{i,k}M_{j,k} = -1$ ,其余情况 $M_{i,k}M_{j,k} = 0$ ,因此结果就是 $v_i,v_j$ 之间的边数.</p>
<p>当 $i = j$ 时,当且仅当存在一条边 $e_k \in E$ 的一端是 $v_i$ 时, $M_{i,k}M_{j,k} = 1$ ,因此结果就是它的度.</p>
<p>接下来我们定义一些 $M$ 的子矩阵,它们是证明的关键.</p>
<blockquote>
<p>Def1 $reduced$ $incidence$ $matrix$ (笑死，根本不会英文翻译，姑且叫它关联减矩阵吧。。。) $M_0$ 是去掉 $M$ 最后一行得到的 $(p-1) \times q$ 的矩阵.</p>
<p>Def2 在此基础上定义一个 $(p-1) \times (p-1)$ 的矩阵 $M_0[S]$ ,其中集合 $S = \{ i_1,i_2,i_3, \dots,i_{p-1} \} \subseteq \{ 1,2,3,\dots,q \}$ .它的意思是,抽出矩阵 $M_0$ 的第 $i_1,i_2,\dots,i_{p-1}$ 列,得到一个新的矩阵，称之为 $M_0[S]$ .</p>
</blockquote>
<p>$S$ 中的每个元素 $i_k$ 都和一条边的 $e_k$ 对应,所以为了方便,以下不区分 $S$ 和它所一一对应的边集.</p>
<p>接下来证明引理2</p>
<blockquote>
<p>Lemma2 令 $S$ 为边集 $E$ 的一个大小为 $p-1$ 的子集,若 $G’ = \left( V,S \right)$ 不构成生成树,则 $\operatorname{det}(M_0[S]) = 0$ ;若构成生成树,则 $\operatorname{det}(M_0[S]) = \pm1$.</p>
</blockquote>
<p>证明:</p>
<p>若 $G’$ 不构成生成树,则 $G’$ 包含圈 $C$ .设 $C$ 是由 $e_1,e_2,e_3,\dots,e_k$ ,共 $k$ 条边构成,那么容易证明矩阵 $M_0[S]$ 中, $i_1,i_2,i_3,\dots,i_k$ 这 $k$ 列线性相关(证明过程类似向量合成的感觉,就矩阵而言会更直观),故 $\operatorname{det}(M_0[S]) = 0$ .</p>
<p>补充:线性相关就是各行或列能互相线性表示,能进行初等变换,把某一行或列变换到另一行或列,最后有一行会全为 $0$ ,计算时行列式就等于 $0$ .所以行列式等于 $0$ 就是线性相关.相反的,线性无关它的行列式不等于 $0$ ,说明是满秩,没有一行或一列全为 $0$ .</p>
<p>若 $G’$ 构成生成树,则我们可以把 $G’$ 中的点进行排序(实际是拓扑排序),排成 $v_1,v_2,v_3,\dots,v_{p-1}$ .其中 $v_1$ 是任意叶子节点, $v_2$ 是 $G’$ 删除 $v_1$ 后任意的叶子节点,以此类推.排序不一定唯一,但总是叶子节点在前,叶子节点总是存在,所以排序总能进行.</p>
<p>然后我们把 $M_0[S]$ 的行重新排序,第一行对应 $v_1$ ,第二行对应 $v_2$ $\cdots$ .之后我们对 $M_0[S]$ 的列重新排序.排序后, $e_1$ 是唯一与 $v_1$ 关联的边(因为它是叶子节点)， $\cdots$ , $e_k$ 是删除 $v_1,v_2,\dots,v_{k-1}$ 后唯一与 $v_k$ 关联的边.边的另一端在矩阵中的编号总大于这个节点,因此我们发现, $M_0[S]$ 已经变成了一个下三角矩阵,主对角线元总是 $\pm1$ ,因此我们得到 $\operatorname{det}(M_0[S]) = \pm1$.</p>
<p>引理证毕.</p>
<blockquote>
<p>Binet-Cauchy定理 设 $A,B$ 是两个 $n \times m$ 的矩阵,则有 $\operatorname{det}(AB) = \sum_S{(\operatorname{det}(A[S]))(\operatorname{det}(B[S]))}$ ,其中 $S$ 的大小为 $m$ ,且是 $\{ 1,2,\dots,m \}$ 的子集. </p>
<p>$A[S]$ 的记号和上面的类似,是取 $A$ 中,与 $S$ 中元素对应的 $m$ 列得到的 $m \times m$ 新矩阵;$B[S]$ 则改为取行,也得到了一个 $m \times m$ 新矩阵.</p>
<p>它是 $\operatorname{det}(AB) = \operatorname{det}(A) \times  \operatorname{det}(B)$ (其中 $A,B$ 同阶方阵)的扩展形式.</p>
</blockquote>
<p>累了不想写证明了,自己去想吧………………….</p>
<p>至此所有引理证明完毕.</p>
<hr>
<h3 id="矩阵树定理"><a href="#矩阵树定理" class="headerlink" title="矩阵树定理"></a><strong>矩阵树定理</strong></h3><blockquote>
<p>MatrixTree定理 设图 $G = (V,E)$ ,Laplace矩阵 $L$ .则 $G$ 的生成树的个数等于 $\operatorname{det}(L_0)$ ,其中 $L_0$ 是去掉 $L$ 第 $i$ 行第 $i$ 列得到的子矩阵( $i$ 任意).</p>
</blockquote>
<p> 证明:</p>
<p> 不妨设去掉最后一行最后一列.</p>
<p> 与引理1类似,我们很容易可以得到 $L_0 = M_0M_0^T$ ,这样,由 $Binet-Cauchy$ 定理可以得到:</p>
<script type="math/tex; mode=display">
\operatorname{det}(L_0) = 
 \sum_S{(\operatorname{det}(M_0[S]))(\operatorname{det}(M_0^T[S]))} \\
 = \sum_S{(\operatorname{det}(M_0[S]))^2}</script><p>而引理2告诉我们,在 $S$ 构成生成树时, $\operatorname{det}(M_0[S]) = \pm1$ ;否则等于 $0$ .因此 $\operatorname{det}(L_0)$ 就等于生成树个数.</p>
<p>证毕.</p>
<p>补充:</p>
<blockquote>
<p>有 $p$ 个顶点的完全图 $K_p$ ,生成树个数为 $p^{p-2}$ 个.</p>
</blockquote>
<p>可以用 $MatrixTree$ 定理来证,相信读者自证不难.</p>
<p>Prüfer序列也能证.</p>
<hr>
<h2 id="矩阵树定理的各种形式"><a href="#矩阵树定理的各种形式" class="headerlink" title="矩阵树定理的各种形式"></a><strong>矩阵树定理的各种形式</strong></h2><p>以下内容均允许重边,但不允许自环.</p>
<h3 id="无向图记号说明"><a href="#无向图记号说明" class="headerlink" title="无向图记号说明"></a>无向图记号说明</h3><p>设 $G$ 是一个有 $n$ 个点的无向图.<br>设 $# e(i,j)$ 为点 $i$ 与点 $j$ 相连的边数.<br>记图 $G$ 的所有生成树个数为 $t(G)$ .</p>
<h3 id="有向图记号说明"><a href="#有向图记号说明" class="headerlink" title="有向图记号说明"></a>有向图记号说明</h3><p>设 $G$ 是一个有 $n$ 个点的有向图.<br>定义出度矩阵 $D^{out}(G)$ 为:</p>
<script type="math/tex; mode=display">
D_{i,i}^{out} = \operatorname{deg^{out}}(i),D_{i,j}^{out} = 0,i \not = j</script><p>类似的定义入度矩阵 $D^{in}(G)$ .<br>设 $# e(i,j)$ 为点 $i$ 指向点 $j$ 相连的边数.<br>定义出度Laplace矩阵 $L^{out}$ 为:</p>
<script type="math/tex; mode=display">
L^{out}(G) = D^{out}(G)-A(G)</script><p>定义入度Laplace矩阵 $L^{in}$ 为:</p>
<script type="math/tex; mode=display">
L^{in}(G) = D^{in}(G)-A(G)</script><p>记图 $G$ 的以 $r$ 为根的所有根向树形图个数为 $t^{root}(G,r)$ .所谓根向树形图是指，这张图的基图是一棵树,所有边全部指向父亲.</p>
<p>记图 $G$ 的以 $r$ 为根的所有叶向树形图个数为 $t^{leaf}(G,r)$ .所谓叶向树形图是指，这张图的基图是一棵树,所有边全部指向儿子.</p>
<hr>
<h3 id="矩阵树定理的各种形式-1"><a href="#矩阵树定理的各种形式-1" class="headerlink" title="矩阵树定理的各种形式"></a><strong>矩阵树定理的各种形式</strong></h3><p>其中1,3,4用得较多.</p>
<blockquote>
<p><strong>定理1(无向图行列式形式)</strong>  对于任意的 $i$ ,都有</p>
<script type="math/tex; mode=display">
t(G) = \operatorname{det}L(G) = 
\left(\begin{array}{cccc}
1,2,\dots,i-1,i+1,\dots,n\\
1,2,\dots,i-1,i+1,\dots,n
\end{array}\right)</script></blockquote>
<p>这个记号是表示第 $1,2,\dots,i-1,i+1,\dots,n$ 行,与第 $1,2,\dots,i-1,i+1,\dots,n$ 列构成的子矩阵.</p>
<blockquote>
<p><strong>定理2(无向图特征值形式)</strong> 设 $\lambda_1,\lambda_2,\dots,\lambda_{n-1}$ 为 $L(G)$ 的 $n-1$ 个非零特征值,那么有</p>
<script type="math/tex; mode=display">
t(G) = \frac{1}{n} \lambda_1 \lambda_2\cdots \lambda_{n-1}</script></blockquote>
<p>线代没学多少,暂时不会,就留坑吧.</p>
<blockquote>
<p><strong>定理3(有向图根向形式)</strong> 对于任意的 $k$ ,都有</p>
<script type="math/tex; mode=display">
t^{root}(G,k) = \operatorname{det}L^{out}(G)
\left(\begin{array}{cccc}
1,2,\dots,k-1,k+1,\dots,n\\
1,2,\dots,k-1,k+1,\dots,n
\end{array}\right)</script></blockquote>
<p>因此如果要统计一张图所有的根向树形图,只要枚举所有的根 $k$ 并对 $t^{root}(G,k)$ 求和即可.</p>
<blockquote>
<p><strong>定理4(有向图叶向形式)</strong> 对于任意的 $k$ ,都有</p>
<script type="math/tex; mode=display">
t^{leaf}(G,k) = \operatorname{det}L^{in}(G)
\left(\begin{array}{cccc}
1,2,\dots,k-1,k+1,\dots,n\\
1,2,\dots,k-1,k+1,\dots,n
\end{array}\right)</script></blockquote>
<p>因此如果要统计一张图所有的叶向树形图,只要枚举所有的根 $k$ 并对 $t^{leaf}(G,k)$ 求和即可.</p>
<hr>
<h2 id="BEST定理"><a href="#BEST定理" class="headerlink" title="BEST定理"></a><strong>BEST定理</strong></h2><blockquote>
<p><strong>定理5(BEST定理)</strong> 设 $G$ 是有向图欧拉图,那么 $G$ 的不同欧拉回路总数 $ec(G)$ 是</p>
<script type="math/tex; mode=display">
ec(G) = t^{root}(G,k)\prod_{v \in V}{(\operatorname{deg}(v)-1)!}</script></blockquote>
<p>注意,对欧拉图 $G$ 的任意两个节点 $k,k’$ ,都有 $t^{root}(G,k) = t^{root}(G,k’)$ ,且欧拉图 $G$ 的所有节点的入度和出度相等.</p>
<hr>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a><strong>例题</strong></h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4111">[HEOI2015]小 Z 的房间</a></p>
<h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a><strong><em>solution</em></strong></h4><p>将每个空房间看成一个节点,将相邻的可连边的点连边,注意只向下和向右连边,这样可以防止重边.得到Laplace矩阵后任意删掉第 $i$ 行第 $i$ 列后求这个行列式即可.</p>
<p>求行列式的方法就是高斯消元成上三角阵然后算对角线积(这题 $n$ 比较小甚至不用什么优化).</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2144">[FJOI2007]轮状病毒</a></p>
<h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a><strong><em>solution</em></strong></h4><p>很直接的矩阵树定理题,麻烦的地方在于你得写高精度.</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4336">[SHOI2016]黑暗前的幻想乡</a></p>
<h4 id="solution-2"><a href="#solution-2" class="headerlink" title="solution"></a><strong><em>solution</em></strong></h4><p>考虑这题有两个限制,要一棵构成生成树,和恰好 $n-1$ 个公司建造公路.<br>对着图跑一遍矩阵树定理即可知道方案数,但这个答案明显多算了,所以考虑容斥.<br>我们计算了刚好由 $n-1$ 个公司建造的生成树个数,但是我们也统计上了刚好由 $n-2$ 个公司建造的生成树.枚举是哪 $n-2$ 个公司建造了这个树,显然这样的集合有 $\dbinom{n-1}{1}$ 种,建图的时候只加入这 $n-2$ 个公司的边,对着这个图跑一边矩阵树就可以求出方案数了对吧,然后依次减去这些集合的方案数.<br>但这是我们发现减多了,把刚好 $n-3$ 个公司建造的方案数多减了,所以要加回来以此类推.<br>同时建图是不同公司建造的相同边注意要记得加成重边.</p>
<p>复杂度为 $O(2^{n-1}(n-1)^3 \operatorname{log}(10^9+7))$ 可以通过.</p>
<hr>
<h3 id="考虑加上边权会是什么样的"><a href="#考虑加上边权会是什么样的" class="headerlink" title="考虑加上边权会是什么样的"></a><strong>考虑加上边权会是什么样的</strong></h3><p>根据乘法原理,对于某种生成树的形态,其贡献为每条边重的次数的乘积.</p>
<p>如果把重边次数理解成权值的话,那么矩阵树定理求的就是:所有生成树边权乘积的总和.</p>
<p>(这里注意度数矩阵变成了相邻边的权值和)</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3317">[SDOI2014]重建</a></p>
<h4 id="solution-3"><a href="#solution-3" class="headerlink" title="solution"></a><strong><em>solution</em></strong></h4><p>众所周知,矩阵树求的是 $\sum_{T}{\prod_{e \in E}{p_e}}$</p>
<p>这道题求的是 $\sum_{T}{(\prod_{e \in E}{p_e}}\prod_{e \not \in E}{(1-p_e))}$</p>
<p>意思是枚举每棵树, $\text{属于这个树的边出现的概率} \times \text{非树边出现的概率}$ .</p>
<script type="math/tex; mode=display">
\sum_{T}{(\prod_{e \in T}{p_e}}\prod_{e \not \in T}{(1-p_e))}\\
= \sum_{T}{(\prod_{e \in T}{p_e\frac{\prod_{e}{(1-p_e)}}{\prod_{e \in T}{(1-p_e)}}})}\\
= \prod_{e}{(1-p_e)(\sum_{T}{\prod_{e \in T}{\frac{p_e}{(1-p_e)}}})}</script><hr>
<h3 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h3><p>考虑不是求边权积, 而是边权和.</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6624">[省选联考 2020 A 卷] 作业题</a></p>
<script type="math/tex; mode=display">
\sum_{T}{\sum_{i=1}^{n-1}{w_{e_i}}}</script><p>首先考虑 $w_i$ 都相同的情况, 直接套模板即可, 最后答案乘上 $w_i$ 就行.</p>
<p>有不同的的话, 先考虑一种暴力的做法, 枚举每一条边, 然后求出包含这条边的生成树个数.</p>
<p>考虑怎么更优, 一次行列式就全算出来.</p>
<p>把矩阵的每个位置改成一个一次函数即可, 将一条边的贡献写成 $w_i x+1$ , 最后答案就是一次项系数.</p>
<p>考虑答案实际上是, 钦定一条边之后的生成树个数 $\times$ 这条边的边权 之和, 那么答案里被乘上一次项系数的边就是被钦定的边.</p>
<hr>
<h3 id="有向扩展"><a href="#有向扩展" class="headerlink" title="有向扩展"></a><strong>有向扩展</strong></h3><p>前面提过要任意去掉第 $k$ 行与第 $k$ 列,是因为无向图所以不用在意谁为根.</p>
<p>在有向树的时候需要理解为指定根,结论是:去掉哪一行就是那一个元素为根.</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4455">[CQOI2018]社交网络</a>(外向树/叶向树)</p>
<h4 id="solution-4"><a href="#solution-4" class="headerlink" title="solution"></a><strong><em>solution</em></strong></h4><p>应该都能看出来是板子题.</p>
<p>注意以 $1$ 为根就删掉第一行第一列.</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6178">【模板】Matrix-Tree 定理</a></p>
<h4 id="solution-5"><a href="#solution-5" class="headerlink" title="solution"></a><strong><em>solution</em></strong></h4><p>还是板子题.</p>
<hr>
<h2 id="BEST定理一个新的矩阵"><a href="#BEST定理一个新的矩阵" class="headerlink" title="BEST定理一个新的矩阵"></a><strong>BEST定理一个新的矩阵</strong></h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5807">Which Dreamed It /【模板】BEST 定理</a></p>
<h4 id="solution-6"><a href="#solution-6" class="headerlink" title="solution"></a><strong><em>solution</em></strong></h4><p>BEST定理的板子题,没有代码难度,下面给出定理证明.</p>
<p>证明:</p>
<p>考虑一个内向树与一个欧拉回路的对应关系.</p>
<h4 id="内向树唯一对应欧拉回路"><a href="#内向树唯一对应欧拉回路" class="headerlink" title="内向树唯一对应欧拉回路"></a><strong>内向树唯一对应欧拉回路</strong></h4><p>对于点 $u (u \not= root)$ ,指定其树边出边为<strong>欧拉回路上最后从 $u$ 离开的边</strong>,而非树边按照指定顺序经过.需要证明这样的欧拉路径合法.</p>
<p>考虑每经过一条边就把这条边删掉,只需证明剩下的边存在欧拉路径,而有向图存在欧拉路径必须满足:</p>
<ul>
<li>点的度数:任意点入度与出度之差都不超过1,且入度不等于出度的点最多只有两个;</li>
<li>弱联通性:有向边变为无向边后所有边(不是点)都在一个联通块里.</li>
</ul>
<p>若原图符合点的限制,新图显然符合,而弱联通性需要讨论.</p>
<ul>
<li>若删去的边是非树边 $(u,v)$ ,由于树边是每个点最后离开的边, $u,v$ 之间的树边一定还没有被删去,则 $u$ 到 $v$ 之间可以通过树边直接形成弱联通.</li>
<li>若删去的边是树边,则删去后 $u$ 与剩下的图完全断开,相当于删去一条链末端的边,剩下的边仍然弱联通.</li>
</ul>
<p>点度数限制与弱连通性仍然满足,新图一定存在欧拉路径,进而说明欧拉回路满足条件.</p>
<h4 id="欧拉回路对应唯一内向树"><a href="#欧拉回路对应唯一内向树" class="headerlink" title="欧拉回路对应唯一内向树"></a><strong>欧拉回路对应唯一内向树</strong></h4><p>对于点 $u (u \not= root)$ ,指定其树边出边为<strong>欧拉回路上最后从 $u$ 离开的边</strong>,而非树边按照指定顺序经过.需要证明树边不成环.</p>
<p>假如成环</p>
<ol>
<li>树边出边是最后离开一个点经过的边,则从树边出边离开 $u$ 后就不会再到达 $u$ ;</li>
<li>第一条说明从 $u$ 经过其树边出边到达 $v$ 时，$v$ 还未经过其树边出边;当 $v$ 经过其所有非树边出边后,会从其树边出边离开;</li>
<li>一直重复第二条的过程,会回到环上的一个点,而该点已经经过了其树边出边,与第一条矛盾.</li>
</ol>
<p>所以树边不会成环,又由于原图 $G$ 满足欧拉回路的度数限制,所以树边构成内向树.</p>
<p>证毕.</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a><strong>补充</strong></h3><p>如果答案要求以某个点 $s$ 为起点的欧拉回路个数,那么答案是</p>
<script type="math/tex; mode=display">
ans = t^{root}(G,s) \operatorname{deg}(s) \prod_{v \in V}{(\operatorname{deg}(v)-1)!}</script>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" rel="tag"># 线性代数</a>
              <a href="/tags/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/" rel="tag"># 矩阵树定理</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/11/05/%E8%A1%8C%E5%88%97%E5%BC%8F/" rel="prev" title="行列式">
                  <i class="fa fa-chevron-left"></i> 行列式
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/11/05/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91ARC126D%20Pure%20Straight/" rel="next" title="【题解】ARC126D Pure Straight">
                  【题解】ARC126D Pure Straight <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">demonlover</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"per_page":false,"cdn":"//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
